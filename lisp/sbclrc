(require :asdf)


;;; IO Stuff
;;

(setf *terminal-io* (make-two-way-stream
		     (make-synonym-stream '*standard-input*)
		     (make-synonym-stream '*standard-output*)))

(setf *print-right-margin* most-positive-fixnum
      *print-miser-width*  most-positive-fixnum)


;;; Loading
;;

(defvar *lisp-share-path* "/vol/cl/share/common-lisp")

#-quicklisp
(let ((quicklisp-init (format nil "~A/quicklisp/setup.lisp" *lisp-share-path*)))
  (when (probe-file quicklisp-init)
    (load quicklisp-init)))

(defun %load-silently (system)
  (let ((*compile-verbose* nil)
	(*compile-print*   nil)
	(*load-verbose*    nil)
	(*load-print*      nil))
    (tagbody
     retry
       (handler-bind
	   ((warning                #'muffle-warning)
	    (sb-ext:compiler-note   #'muffle-warning)
	    (asdf:missing-component
	     #'(lambda (condition)
		 ;; defined below
		 (funcall
		  (intern "%LOAD-SYSTEM-FROM-ARTIFACT")
		  (asdf::missing-requires condition))
		 (go retry)))
	    (quicklisp-client::system-not-found
	     #'(lambda (condition)
		 ;; defined below
		 (funcall
		  (intern "%LOAD-SYSTEM-FROM-ARTIFACT")
		  (quicklisp-client::system-not-found-name condition))
		 (go retry))))
	 (ql:quickload system :verbose nil :explain nil :prompt nil)))))

(defun %load-dependencies-silently (system)
  (let* ((system (asdf:find-system system))
	 (deps   (remove-duplicates
		  (apply #'append
			 (map 'list #'rest
			      (rest (asdf:component-depends-on
				     'asdf:load-op system)))))))
    (map 'nil #'%load-silently deps)))


;;; Systems from
;; + /vol/cl/share/common-lisp/site-systems
;; + /vol/cl/share/common-lisp/quicklisp/dists/quicklisp/software
;;

(%load-silently :sb-cover) ;; force ASDF init

(let ((asds (mapcar #'pathname-name
		    (mapcan (lambda (d) (directory (merge-pathnames "*.asd" d)))
			    (asdf::source-registry)))))
  (flet ((add-system-directory (asd)
	   (unless (member (pathname-name asd) asds
			   :test #'string=)
	     (let ((pathname (make-pathname :directory (pathname-directory asd))))
	       (unless (member (namestring pathname) (asdf::source-registry)
			       :test #'string=
			       :key  #'namestring)
		 (format *trace-output* "~&~@<; ~@;adding ~A to source registry~@:>"
			 pathname))
	       (pushnew pathname (asdf::source-registry)
			:test #'string=
			:key  #'namestring)))))
    (map nil #'add-system-directory
	 (append
	  (directory (format nil "~A/site-systems/**/*.asd" *lisp-share-path*))
	  (directory (format nil "~A/quicklisp/dists/quicklisp/software/**/*.asd" *lisp-share-path*))))))


;;; Downloading Artifacts
;;

(%load-silently :sb-posix)
(%load-silently :alexandria)
(%load-silently :drakma)

(defvar *jenkins-base-url*
  (let ((url (sb-posix:getenv "HUDSON_URL")))
    (subseq url 0 (position #\/ url :from-end t)))
  "Base URL of the jenkins instance that has the artifacts.")

(defvar *job-name* (sb-posix:getenv "JOB_NAME")
  "Our job name.")

(defvar *job-workspace* (sb-posix:getenv "WORKSPACE")
  "Our workspace.")

(defun %download-project-artifact (name destination-directory)
  (let ((url         (format nil "~A/job/~A/lastSuccessfulBuild/artifact/~:*~A.tar.gz"
			     *jenkins-base-url* name))
	(destination (make-pathname
		      :name     (concatenate 'string name ".tar")
		      :type     "gz"
		      :defaults destination-directory)))
    ;;
    (ensure-directories-exist destination-directory)

    ;; Download the artifact archive.
    (format t "~&~@<; ~@;fetching ~S~@:>" url)
    (alexandria:with-output-to-file (stream destination
					    :if-does-not-exist :create
					    :if-exists         :supersede
					    :element-type      '(unsigned-byte 8))
      (let ((http-stream (drakma:http-request url :want-stream t)))
	(alexandria:copy-stream http-stream stream
				:element-type '(unsigned-byte 8))))

    ;; Extract the archive.
    (format t "~&~@<; ~@;extracting ~A~@:>" destination)
    (sb-posix:chdir (namestring destination-directory)) ;; really? :(
    (unless (zerop
	     (sb-ext:process-exit-code
	      (sb-ext:run-program
	       "tar" (list "-xzf" (namestring destination))
	       :search t
	       :wait   t)))
      (error "~@<Could not extract artifact archive ~A~@:>"
	     destination))))

(defun %load-system-from-artifact (system-name)
  (let ((name (string-downcase (string system-name)))
	(deps (format nil "~A/deps/" *job-workspace*)))
    (format t "~&~@<; ~@;loading system from artifact ~A~@:>"
	    system-name)
    (%download-project-artifact name deps)

    (let ((asd (first (directory (merge-pathnames
				  (make-pathname
				   :directory (list :relative name :wild-inferiors)
				   :name      name
				   :type      "asd")
				  deps)))))
      (format t "~&~@<; ~@;loading system definition from ~A~@:>" asd)
      (load asd))))


;;; ASDF System Connections
;;

(if (asdf:find-system :asdf-system-connections nil)
    (progn
      (%load-silently :asdf-system-connections)

      ;; Disable automatic loading of our system in case it is a
      ;; system connection.
      (fmakunbound 'asdf::required-systems-loaded-p)
      (defun asdf::required-systems-loaded-p (connection)
	(unless (string-equal (asdf:component-name connection)
			      *job-name*)
	  (every #'asdf::system-loaded-p (asdf::systems-required connection))))

      (format *trace-output* "~&~@<; ~@;loading system connection definitions~@:>")
      (let ((system-connections
	     (remove-duplicates
	      (mapcan
	       (lambda (dir)
		 (directory (merge-pathnames "*-and-*.asd" dir)))
	       (asdf::source-registry))
	      :test #'string= :key #'pathname-name)))
	(dolist (path system-connections)
	  (format *trace-output*
		  "~&~@<; ~@;loading system connection definition ~A from ~A~@:>"
		  (pathname-name path) path)
	  (handler-case
	      (load path)
	    (error (condition)
	      (warn "~@<Could not load system connection ~A: ~A~@:>"
		    (pathname-name path) condition))))))
    (warn "Could not load system connections"))


;;; Iterate should always declare variables
;;

(%load-silently :iterate)
(setf iterate::*always-declare-variables* t)


;;; Mainly for LispLab
;;

(setf *read-default-float-format* 'double-float)

(defvar *lisplab-libblas-path*   #P"/usr/lib/libblas.so")
(defvar *lisplab-liblapack-path* #P"/usr/lib/liblapack.so")
(defvar *lisplab-libfftw-path*   #P"/usr/lib/libfftw3.so")
